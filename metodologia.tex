
\chapter{Materiais e Métodos}
\label{metodologia}
Este capítulo descreve as tecnologias e etapas para o desenvolvimento
do sistema proposto neste trabalho.

\section{Tecnologias utilizadas}
\label{tecnologias-usadas}

\subsection{Comunicação Wi-Fi e \emph{probe request}}

Segundo \cite{Teleco2008}, uma Wireless LAN (WLAN) é uma rede local sem fio padronizada pelo IEEE 802.11. É conhecida também pelo nome de Wi-Fi, abreviatura de ‘wireless fidelity’ (fidelidade sem fios) e marca registrada pertencente à Wireless Ethernet Compatibility Alliance (WECA).

De acordo com \cite{SIMOES2015}, A tecnologia Wi-Fi é muito utilizada em sistemas de posicionamento indoor, pois não existe a necessidade de criar uma infraestrutura de comunicação: em praticamente todos os espaços fechados com afluência de pessoas, existe já uma criada. Vale ressaltar, porém, que redes Wi-Fi estão sujeitas a pontos cegos (desvios de sinal em áreas não atingidas pela rede) - isso pode ser causados por interferências de outros equipamentos, objetos, fiação elétrica ou mesmo paredes. Dispositivos a uma mesma distância de um ponto de acesso podem receber qualidades de sinal diferentes.

Ainda segundo \cite{SIMOES2015}, um campo de informação que pode ser recolhido pelos dispositivos móveis é o MAC Address, que permite identificar, na rede, o AP ao qual o aparelho está ligado, característica esta utilizada no desenvolvimento deste trabalho.

Como explanado por \cite{Teleco2016}, para permitir que uma estação móvel comunique-se com outras em uma rede IBSS (Independent Basic Service Set) ou um AP em uma rede infra-estrutura BSS (Basic Service Set), ela deve primeiramente encontrá-las: esse processo é conhecido como \emph{varredura} e pode ser de 2 tipos: Passivo, modalidade envolvendo somente a “escuta” de tráfego, e Ativo (método utilizado neste trabalho), no qual a estação X executa uma varredura para extrair informações das demais estações e dos AP’s, economizando tempo. Para tanto, a estação ativamente transmite \emph{queries} (perguntas para extrair as respostas das estações numa BSS), movendo-se então para um canal e transmitindo um quadro do tipo \emph{probe request} (requisição de sondagem): se houver BSS no canal que coincida com o SSID (Service Set Identifier) do quadro “requisição de sondagem”, a estação irá responder, enviando um quadro \emph{probe response} (resposta de sondagem) para a estação que fez a pergunta.

\subsection{Modo monitor}
\label{modo-monitor}
Para que um dispositivo móvel seja identificado independente de qualquer rede ou AP, é essencial que o sistema de detecção possua uma placa e/ou adaptador de rede (NIC) que possa ser habilitado para o modo monitor.

Geralmente, uma interface de rede qualquer captura pacotes dos tipos \emph{managed} e \emph{beacons} que são originados por APs. Estes pacotes são transmitidos
muitas vezes por segundo por APs para indicar quais redes estão realizando \emph{broadcasting}. O modo monitor (\emph{monitor mode}) é um modo de operação em que um NIC consegue capturar todos os tipos de pacotes sem estar associado a um AP \cite{Acrylic} \cite{Wireshark2017b}. Dessa forma, é possível capturar todos os tipos, como os de \emph{probe request} que são enviados de dispositivos móveis.

Neste trabalho, um Raspberry Pi com um adaptador Wi-Fi habilitado no modo monitor captura pacotes \emph{probe request} de dispositivos móveis
para que ocorra a identificação de indivíduos.

\subsection{Tshark}
O protocolo Tshark é a versão de terminal do protocolo
analisador de rede Wireshark \cite{Wireshark2017} \cite{Wireshark2017a}. Ele é
utilizado para analisar e filtrar (\emph{sniff}) os
pacotes capturados. Esse protocolo foi
escolhido, pois permite realizar o estudo da rede a partir do recebimento de
pacotes e seus campos, além de possuir ampla documentação, maturidade e exemplos
por ser uma tecnologia aberta. Um exemplo de seu uso é o comando a seguir.

\begin{center}
\emph{tshark -i wlan1 -T fields -e wlan.sa -e frame.time}
\end{center}

Cada parte do comando anterior significa:
\begin{itemize}
  \item \textbf{wlan1}: interface de rede que indica a antena Wi-Fi utilizada;
  \item \textbf{wlan.sa}: mostra o endereço MAC do dispositivo que enviou o pacote (em inglês, \emph{source address});
  \item \textbf{frame.time}: mostra a hora, dia e ano em que o pacote foi capturado;
\end{itemize}

A saída no terminal do comando apresentado está na \autoref{saida-comando}.

\begin{figure}[htb]
  \caption{\label{saida-comando}Saída após execução de comando Tshark}
  \begin{center}
    \includegraphics[width=0.90\textwidth]{img/packets.png}
  \end{center}
  \legend{Fonte: Elaborada pelas autoras.}
\end{figure}

\subsection{Raspberry Pi}
O Raspberry Pi é um computador do tamanho de um cartão de crédito que pode ser conectado a monitores, teclados, mouse e outros dispositivos.
Para a detecção de dispositivos móveis um Raspberry Pi Model 3 B juntamente com um adaptador Wi-Fi são utilizados. O Raspberry foi escolhido,
pois oferece interface amigável de programação (terminais gráfico e de texto); possui poder de processamento para receber os milhares de pacotes, pré-processá-los
e enviar para o servidor; possui entrada USB pode receber uma antena Wi-Fi e seu tamanho pequeno \cite{rpi2017}.

Outras opções foram consideradas por serem baratas, acessíveis e terem documentação aberta. Foi o caso do ESP8266 que possui um tamanho extremamente
reduzido e possui o custo médio de R\$15,00 \cite{Embarcados2015}, mas seu uso para este trabalho fica impossibilitado. Isso
ocorre, pois essa tecnologia não consegue ser habilitada para o modo monitor da interface de rede \cite{Puhl2016} \cite{Ferreira2016}.

Uma antena Wi-Fi (Ralink MT7601U) foi equipada no Raspberry para ampliar o alcance da captura já que o propósito do sistema é detecção em zonas que podem
apresentar esparcidade de indivíduos (espalhados) e já que ela pôde ser habilitada para o modo monitor (\autoref{modo-monitor}). A antena nativa
do Raspberry não conseguiu ser habilitada para o \emph{monitor mode}.

O sistema operacional utilizado com esta ferramenta foi o Kali Linux, pois dentre os sistemas testados foi o que possui suporte de \emph{drivers} para a antena Ralink utilizada. Outro ponto é que este SO foi projetado
para experimentos e projetos relacionados, então possui ampla documentação e exemplos nesse sentido \cite{kali}

\subsection{Node.js}
O Node ou Node.js é um \emph{runtime} que permite a execução Javascript fora dos navegadores, nesse caso do lado dos servidores \cite{node}.
Essa ferramenta permite a criação de APIs com entradas e saídas (I/O) não bloqueantes, ou seja, emprega programação assíncrona \cite{Dzone}. Para tal, essa tecnologia é orientada a eventos, assim que um evento ocorre funções específicas são
acionada para tratá-lo. Nesse cenário, os comandos executam em paralelo utilizando funções de \emph{callback}. Para o sistema proposto nesse trabalho, é uma característica muito importante
já que trata de um "sistema quase em tempo real", ou seja, é possível atender todas as requisições feitas pelo usuário para a visualização dos dados, como
a postagem de arquivos provenientes do módulo sensor (\autoref{sensor-cap}).

No GSMART, o Node é utilizado tanto na parte do servidor como na parte que executa os comandos do Tshark dentro do Kali Linux, demonstrando ainda mais sua versatilidade.

Outro componente importante do Node é a importação de pacotes produzidos pela comunidade aberta através do gerenciador de pacotes NPM (Node
Package Manager), sendo essencial para facilitar e agilizar a programação. Por exemplo, o servidor deste projeto é baseado no pacote Express.js.

O Express.js é um \emph{framework} que fornece conjunto robusto para aplicativos web, como: métodos HTTP e \emph{middleware} \cite{express}. Na \autoref{express} é possível observar o tratamento
de uma das rotas de acesso à aplicação de apresentação de dados construído facilmente com o Express. Para importar este pacote, basta abrir o terminar no diretório do projeto e executar o comando \emh{npm install --save express}.

\begin{figure}[htb]
  \caption{\label{express}Código utilizando Express.js}
  \begin{center}
    \includegraphics[width=0.90\textwidth]{img/express.png}
  \end{center}
  \legend{Fonte: Elaborada pelas autoras.}
\end{figure}

Na linha 1, importa-se o pacote. Já na linha 11, ele faz o tratamento da rota "login", caso o usuário tente acessá-la (método GET), será retornado uma mensagem de "Você está logado!". Na linha 15, o servidor está escutando a porta 3000 para acesso. Esse trecho de código é um exemplo de como a programação
com Node e seus pacotes por ser simplificada.

<<<<<<< HEAD
A implementação deste trabalho seguiu 3 etapas distintas: inicialmente, foi feito o levantamento teórico acerca de \emph{geomarketing} - devido à abrangência do tema, fez-se necessário definir qual seria o viés a ser seguido. Decidiu-se focar o desenvolvimento em conceitos relativos à contagem de pessoas e aferição de tráfego local. Foi realizado também um levantamento bibliográfico a respeito de empresas e projetos semelhantes ao proposto nesta monografia. 

A segunda etapa envolveu a escolha dos materiais e tecnologias a serem utilizados na concepção de um contator de pessoas. Foram realizados testes de compatibilidade entre hardware e Sistema operacional - no caso, utilizando-se como base o dispositivo portátil Raspberry Pi conforme \autoref{tecnologias-usadas}, fizeram-se testes para encontrar o SO adequado às necessidades do projeto, além de testes para escolha de uma antena Wi-Fi compatível com as especificações tecnológicas, uma vez que a antena nativa do Raspberry Pi não funciona em modo monitor, algo imprescindível na captura de pacotes específicos. Após selecionar hardware e SO, foram escolhidas as demais tecnologias e ferramentas a serem usadas no desenvolvimento da aplicação e visualização de dados, que se daria em forma de uma \emph{web page}: linguagens de programação, bancos de dados e servidores.

Na terceira etapa, durante e após o desenvolvimento e interligação de tecnologias e ferramentas, fizeram-se alguns testes em ambiente controlado para observar o comportamento do  contator e verificar se a captura de pacotes e contagem estavam ocorrendo como previsto. Foram realizados diversos ajustes a fim de otimizar a precisão da contagem, levando-se em conta o fato de que a aferição é uma estimativa média de tráfego e que existem limitações tecnológicas envolvidas. Após obtidos os resultados finais, fizeram-se testes extensivos (tanto em ambiente controlado quanto comercial) a fim de verificar-se a eficácia do dispositivo e também criar um banco de dados real, fornecendo os dados necessários ao \emph{website} para processamento e geração de informação.
=======
O último ponto para a escolha do Node.js foi o fato dele ser baseado na \emph{engine} V8 de Javascript do Google
Chrome, possibilitando utilizar Javascript tanto para o servidor quanto no lado do cliente.
>>>>>>> 30bc4c5b9deb96c415e30afe234d92169d62f5e2

\subsection{MongoDB}
O MongoDB é um banco de dados NoSQL baseado em coleções de documentos. O número de campos, conteúdo e tamanho de cada documento pode ser
diferente \cite{mongo}. Cada um desses documentos é representado por um objeto javascript (JSON). Além disso, o MongoDB oferece API que forece \emph{queries} rápidas e semelhantes ao SQL.

Este banco de dados foi utilizado no projeto devido a representação dos dados em
JSON já que a aplicação é interamente em Javascript, ou seja, facilitando
manipulação pelas funções. Outro ponto é a escalabilidade, uma vez que no início
do projeto o custo de uma \emph{query} e o tamanho em \emph{bytes} da unidade do
dado não era conhecidos. Além disso, optou-se por um banco relacional, pois os dados utilizados organizados em tabelas
consumiria demasiado desempenho da aplicação. O modelo de dado será apresentado no \autoref{arq-cap}.

Por fim, os documentos do MongoDB foram manipulados pelo Node.js através do pacote Mongoose que proporciona variadas
funções para abstrair as \emph{queries}.

\section{Métodos e Etapas}
Como a aplicação foi desenvolvida, etc. etc.. ordem de desenvolvimento
